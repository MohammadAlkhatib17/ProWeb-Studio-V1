/**
 * 404 Monitoring and Smart Redirects System
 * Tracks broken links, analyzes patterns, and suggests intelligent redirects
 */

import { URLSimilarity, AlertManager, CacheManager } from './utils';
import { MONITORING_CONFIG } from './config';
import type { NotFoundMonitoring, SmartRedirect } from './types';

export interface NotFoundAnalytics {
  totalNotFound: number;
  uniqueUrls: number;
  topMissingPages: Array<{ url: string; hits: number; lastSeen: number }>;
  topReferrers: Array<{ referrer: string; hits: number }>;
  deviceBreakdown: Record<string, number>;
  trends: Array<{ date: string; count: number }>;
  patterns: NotFoundPattern[];
}

export interface NotFoundPattern {
  pattern: string;
  count: number;
  examples: string[];
  suggestedAction: 'redirect' | 'create-content' | 'fix-links' | 'ignore';
  confidence: number;
}

export interface RedirectSuggestion {
  from: string;
  to: string[];
  confidence: number;
  reason: string;
  evidence: {
    similarUrls: Array<{ url: string; similarity: number }>;
    referrerAnalysis: string[];
    contentAnalysis?: string;
  };
}

export class NotFoundMonitor {
  private notFoundData: Map<string, NotFoundMonitoring> = new Map();
  private redirects: Map<string, SmartRedirect> = new Map();
  private siteUrls: Set<string> = new Set();

  constructor() {
    this.loadExistingSiteUrls();
  }

  /**
   * Record a 404 occurrence
   */
  record404(
    url: string,
    referrer?: string,
    userAgent?: string,
    ipAddress?: string
  ): void {
    // Check if URL should be ignored
    if (this.shouldIgnoreUrl(url)) {
      return;
    }

    const key = this.normalizeUrl(url);
    const existing = this.notFoundData.get(key);
    const now = Date.now();

    if (existing) {
      existing.frequency++;
      existing.timestamp = now;
      if (referrer) existing.referer = referrer;
    } else {
      const notFoundEntry: NotFoundMonitoring = {
        url: key,
        timestamp: now,
        referer: referrer,
        userAgent: userAgent || 'Unknown',
        ipAddress: ipAddress || 'Unknown',
        frequency: 1,
        isFixed: false,
      };

      this.notFoundData.set(key, notFoundEntry);
    }

    // Check if we need to generate redirect suggestions
    this.checkForRedirectOpportunity(key);

    // Create alert if frequency threshold exceeded
    this.checkAlertThreshold(key);
  }

  /**
   * Generate smart redirect suggestions for a 404 URL
   */
  async generateRedirectSuggestions(notFoundUrl: string): Promise<RedirectSuggestion[]> {
    const suggestions: RedirectSuggestion[] = [];
    const normalizedUrl = this.normalizeUrl(notFoundUrl);

    // Get similar URLs from existing site content
    const similarUrls = URLSimilarity.findSimilarUrls(
      normalizedUrl,
      Array.from(this.siteUrls)
    );

    if (similarUrls.length > 0) {
      suggestions.push({
        from: normalizedUrl,
        to: similarUrls.slice(0, 3).map(item => item.url),
        confidence: similarUrls[0].similarity,
        reason: 'URL similarity analysis',
        evidence: {
          similarUrls: similarUrls.slice(0, 5),
          referrerAnalysis: this.analyzeReferrers(normalizedUrl),
        },
      });
    }

    // Analyze based on content patterns
    const contentSuggestions = await this.analyzeContentPatterns(normalizedUrl);
    suggestions.push(...contentSuggestions);

    // Analyze referrer patterns
    const referrerSuggestions = this.analyzeReferrerPatterns(normalizedUrl);
    suggestions.push(...referrerSuggestions);

    return suggestions.sort((a, b) => b.confidence - a.confidence);
  }

  /**
   * Create a smart redirect
   */
  createRedirect(
    from: string,
    to: string,
    type: 301 | 302 | 307 | 308 = 301,
    reason: SmartRedirect['reason'] = 'similar-content',
    autoGenerated = true
  ): SmartRedirect {
    const redirect: SmartRedirect = {
      from: this.normalizeUrl(from),
      to: this.normalizeUrl(to),
      type,
      reason,
      confidence: this.calculateRedirectConfidence(from, to),
      autoGenerated,
      timestamp: Date.now(),
    };

    this.redirects.set(redirect.from, redirect);

    // Mark the 404 as fixed
    const notFoundEntry = this.notFoundData.get(redirect.from);
    if (notFoundEntry) {
      notFoundEntry.isFixed = true;
      notFoundEntry.suggestedRedirect = redirect.to;
    }

    return redirect;
  }

  /**
   * Get analytics for 404 errors
   */
  getAnalytics(days: number = 30): NotFoundAnalytics {
    const cutoff = Date.now() - (days * 24 * 60 * 60 * 1000);
    const recentData = Array.from(this.notFoundData.values())
      .filter(item => item.timestamp > cutoff);

    const topMissingPages = this.getTopMissingPages(recentData);
    const topReferrers = this.getTopReferrers(recentData);
    const deviceBreakdown = this.getDeviceBreakdown(recentData);
    const trends = this.getTrends(recentData, days);
    const patterns = this.detectPatterns(recentData);

    return {
      totalNotFound: recentData.reduce((sum, item) => sum + item.frequency, 0),
      uniqueUrls: recentData.length,
      topMissingPages,
      topReferrers,
      deviceBreakdown,
      trends,
      patterns,
    };
  }

  /**
   * Get redirect suggestions for dashboard
   */
  getRedirectSuggestions(limit: number = 10): Array<{url: string; suggestions: RedirectSuggestion[]}> {
    const unfixed = Array.from(this.notFoundData.values())
      .filter(item => !item.isFixed && item.frequency >= 3)
      .sort((a, b) => b.frequency - a.frequency)
      .slice(0, limit);

    return unfixed.map(item => ({
      url: item.url,
      suggestions: [], // Would be populated with actual suggestions
    }));
  }

  /**
   * Detect broken internal links
   */
  async detectBrokenLinks(siteUrl: string): Promise<Array<{page: string; brokenLinks: string[]}>> {
    const brokenLinks: Array<{page: string; brokenLinks: string[]}> = [];
    
    try {
      // This would crawl the site to find broken internal links
      // For now, return example data based on 404s with referrers
      const internalReferrers = Array.from(this.notFoundData.values())
        .filter(item => item.referer && item.referer.includes(siteUrl))
        .reduce((acc, item) => {
          const referrer = item.referer!;
          if (!acc[referrer]) acc[referrer] = [];
          acc[referrer].push(item.url);
          return acc;
        }, {} as Record<string, string[]>);

      for (const [page, links] of Object.entries(internalReferrers)) {
        brokenLinks.push({ page, brokenLinks: links });
      }
    } catch (error) {
      console.error('Broken link detection failed:', error);
    }

    return brokenLinks;
  }

  private shouldIgnoreUrl(url: string): boolean {
    const ignorePatterns = MONITORING_CONFIG.NOT_FOUND_MONITORING.IGNORE_PATTERNS;
    return ignorePatterns.some(pattern => pattern.test(url));
  }

  private normalizeUrl(url: string): string {
    try {
      const urlObj = new URL(url);
      return urlObj.pathname.toLowerCase().replace(/\/$/, '') || '/';
    } catch {
      return url.toLowerCase().replace(/\/$/, '') || '/';
    }
  }

  private async loadExistingSiteUrls(): Promise<void> {
    try {
      // Load from sitemap or crawl results
      const cached = CacheManager.get<string[]>('site-urls');
      if (cached) {
        cached.forEach(url => this.siteUrls.add(url));
        return;
      }

      // Fallback to common URLs - in production this would load from sitemap
      const commonUrls = [
        '/',
        '/about',
        '/services',
        '/contact',
        '/blog',
        '/portfolio',
        '/team',
        '/careers',
      ];

      commonUrls.forEach(url => this.siteUrls.add(url));
      CacheManager.set('site-urls', commonUrls, 3600); // Cache for 1 hour
    } catch (error) {
      console.error('Failed to load site URLs:', error);
    }
  }

  private checkForRedirectOpportunity(url: string): void {
    const entry = this.notFoundData.get(url);
    if (!entry || entry.frequency < 3) return;

    // Generate suggestions asynchronously
    this.generateRedirectSuggestions(url).then(suggestions => {
      if (suggestions.length > 0 && suggestions[0].confidence > 0.8) {
        AlertManager.createAlert(
          '404',
          'medium',
          'High-Confidence Redirect Opportunity',
          `URL "${url}" has ${entry.frequency} hits and a strong redirect candidate`,
          url,
          { suggestions: suggestions.slice(0, 3) }
        );
      }
    }).catch(error => {
      console.error('Failed to generate redirect suggestions:', error);
    });
  }

  private checkAlertThreshold(url: string): void {
    const entry = this.notFoundData.get(url);
    if (!entry) return;

    const threshold = MONITORING_CONFIG.NOT_FOUND_MONITORING.FREQUENCY_THRESHOLD;
    
    if (entry.frequency === threshold) {
      AlertManager.createAlert(
        '404',
        'high',
        'Frequent 404 Error',
        `URL "${url}" has been requested ${entry.frequency} times`,
        url,
        { frequency: entry.frequency, referrer: entry.referer }
      );
    }
  }

  private analyzeReferrers(url: string): string[] {
    const entry = this.notFoundData.get(url);
    if (!entry || !entry.referer) return [];

    // Analyze referrer to understand context
    const analysis: string[] = [];
    
    if (entry.referer.includes('google.com')) {
      analysis.push('Referred from Google Search - likely SEO opportunity');
    } else if (entry.referer.includes(process.env.NEXT_PUBLIC_SITE_URL || '')) {
      analysis.push('Internal referrer - broken link that should be fixed');
    } else {
      analysis.push('External referrer - consider creating content or redirect');
    }

    return analysis;
  }

  private async analyzeContentPatterns(url: string): Promise<RedirectSuggestion[]> {
    const suggestions: RedirectSuggestion[] = [];
    
    // Analyze URL structure to suggest similar content
    const pathParts = url.split('/').filter(Boolean);
    
    if (pathParts.length > 0) {
      const category = pathParts[0];
      const matchingUrls = Array.from(this.siteUrls)
        .filter(siteUrl => siteUrl.includes(category))
        .slice(0, 3);

      if (matchingUrls.length > 0) {
        suggestions.push({
          from: url,
          to: matchingUrls,
          confidence: 0.6,
          reason: 'Content category match',
          evidence: {
            similarUrls: matchingUrls.map(u => ({ url: u, similarity: 0.6 })),
            referrerAnalysis: [`Category "${category}" matches existing content`],
            contentAnalysis: 'URL structure suggests similar content type',
          },
        });
      }
    }

    return suggestions;
  }

  private analyzeReferrerPatterns(url: string): RedirectSuggestion[] {
    const suggestions: RedirectSuggestion[] = [];
    const entry = this.notFoundData.get(url);
    
    if (!entry || !entry.referer) return suggestions;

    // If referrer is internal, suggest homepage or similar
    if (entry.referer.includes(process.env.NEXT_PUBLIC_SITE_URL || '')) {
      suggestions.push({
        from: url,
        to: ['/'],
        confidence: 0.4,
        reason: 'Internal referrer fallback',
        evidence: {
          similarUrls: [{ url: '/', similarity: 0.4 }],
          referrerAnalysis: ['Internal link - redirect to homepage as fallback'],
        },
      });
    }

    return suggestions;
  }

  private calculateRedirectConfidence(from: string, to: string): number {
    return URLSimilarity.calculateSimilarity(from, to);
  }

  private getTopMissingPages(data: NotFoundMonitoring[]): Array<{ url: string; hits: number; lastSeen: number }> {
    return data
      .sort((a, b) => b.frequency - a.frequency)
      .slice(0, 10)
      .map(item => ({
        url: item.url,
        hits: item.frequency,
        lastSeen: item.timestamp,
      }));
  }

  private getTopReferrers(data: NotFoundMonitoring[]): Array<{ referrer: string; hits: number }> {
    const referrerCount = new Map<string, number>();
    
    data.forEach(item => {
      if (item.referer) {
        const count = referrerCount.get(item.referer) || 0;
        referrerCount.set(item.referer, count + item.frequency);
      }
    });

    return Array.from(referrerCount.entries())
      .map(([referrer, hits]) => ({ referrer, hits }))
      .sort((a, b) => b.hits - a.hits)
      .slice(0, 10);
  }

  private getDeviceBreakdown(data: NotFoundMonitoring[]): Record<string, number> {
    const breakdown = { mobile: 0, desktop: 0, tablet: 0, other: 0 };
    
    data.forEach(item => {
      const ua = item.userAgent.toLowerCase();
      if (ua.includes('mobile')) breakdown.mobile += item.frequency;
      else if (ua.includes('tablet')) breakdown.tablet += item.frequency;
      else if (ua.includes('mozilla')) breakdown.desktop += item.frequency;
      else breakdown.other += item.frequency;
    });

    return breakdown;
  }

  private getTrends(data: NotFoundMonitoring[], days: number): Array<{ date: string; count: number }> {
    const dailyCounts = new Map<string, number>();
    const now = new Date();
    
    // Initialize all days with 0
    for (let i = 0; i < days; i++) {
      const date = new Date(now);
      date.setDate(date.getDate() - i);
      const dateStr = date.toISOString().split('T')[0];
      dailyCounts.set(dateStr, 0);
    }

    // Count actual occurrences
    data.forEach(item => {
      const date = new Date(item.timestamp).toISOString().split('T')[0];
      if (dailyCounts.has(date)) {
        dailyCounts.set(date, (dailyCounts.get(date) || 0) + item.frequency);
      }
    });

    return Array.from(dailyCounts.entries())
      .map(([date, count]) => ({ date, count }))
      .sort((a, b) => a.date.localeCompare(b.date));
  }

  private detectPatterns(data: NotFoundMonitoring[]): NotFoundPattern[] {
    const patterns: NotFoundPattern[] = [];
    const pathPatterns = new Map<string, string[]>();

    // Group by common path patterns
    data.forEach(item => {
      const path = item.url;
      const parts = path.split('/').filter(Boolean);
      
      if (parts.length > 0) {
        const pattern = parts[0]; // First path segment
        if (!pathPatterns.has(pattern)) {
          pathPatterns.set(pattern, []);
        }
        pathPatterns.get(pattern)!.push(path);
      }
    });

    // Convert to pattern objects
    pathPatterns.forEach((urls, pattern) => {
      if (urls.length >= 3) { // Only patterns with 3+ occurrences
        patterns.push({
          pattern,
          count: urls.length,
          examples: urls.slice(0, 5),
          suggestedAction: this.getSuggestedAction(pattern, urls),
          confidence: Math.min(urls.length / 10, 1), // Max confidence of 1.0
        });
      }
    });

    return patterns.sort((a, b) => b.count - a.count);
  }

  private getSuggestedAction(pattern: string, urls: string[]): NotFoundPattern['suggestedAction'] {
    // Simple heuristics for suggested actions
    if (pattern.includes('wp-') || pattern.includes('admin')) return 'ignore';
    if (urls.length > 10) return 'create-content';
    if (urls.some(url => this.siteUrls.has(url.replace(/\/$/, '')))) return 'redirect';
    return 'fix-links';
  }
}

export const notFoundMonitor = new NotFoundMonitor();